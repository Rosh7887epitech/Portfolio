/*!
\page server_devguide Server Developer Guide ğŸ› ï¸

\tableofcontents

\section server_dev_intro Welcome, Developer! ğŸ‘¨â€ğŸ’»

This guide will help you understand the internal architecture of the Zappynian server, its core components, and how to extend or modify its functionality. Get ready to dive deep into the code! ğŸŠâ€â™‚ï¸

\section server_architecture Architecture Overview ğŸ—ï¸

The Zappynian server follows a modular architecture with clear separation of concerns:

```
Server Core
â”œâ”€â”€ Network Layer (libzappy_net) ğŸŒ
â”œâ”€â”€ Game Logic Layer ğŸ®
â”œâ”€â”€ World Management ğŸŒ
â”œâ”€â”€ Player Management ğŸ‘¤
â”œâ”€â”€ Command Processing âš¡
â”œâ”€â”€ Timing System â°
â””â”€â”€ GUI Integration ğŸ–¥ï¸
```

\section server_core_structures Core Data Structures ğŸ“Š

\subsection server_struct Main Server Structure ğŸ¢

```c
typedef struct server_s {
    server_args_t *args;                    // Server configuration ğŸ”§
    server_connection_t *connection;        // Network connections ğŸ”—
    map_t *map;                            // Game world ğŸ—ºï¸
    player_t **players;                    // Active players ğŸ‘¥
    size_t player_count;                   // Player count ğŸ“ˆ
    int tick_count;                        // Game ticks â±ï¸
    bool game_running;                     // Game state ğŸŸ¢
    volatile bool server_running;          // Server state ğŸš¦
    egg_t *eggs;                          // Egg entities ğŸ¥š
    graphic_client_list_t *graphic_clients; // GUI clients ğŸ–¥ï¸
    timing_manager_t *timing_manager;      // Command timing âš™ï¸
    void *food_timer;                      // Food management ğŸ–
} server_t;
```

\subsection server_player_struct Player Structure ğŸ‘¤

```c
typedef struct player_s {
    int id;                                    // Unique identifier ğŸ·ï¸
    char *team_name;                          // Team affiliation ğŸ³ï¸
    int x, y;                                 // World position ğŸ“
    int level;                                // Player level ğŸ“Š
    int orientation;                          // Facing direction ğŸ§­
    int food;                                 // Food units ğŸ–
    int resources[RESOURCE_COUNT];            // Inventory ğŸ’
    bool dead;                                // Alive status ğŸ’€
    bool in_elevation;                        // Elevation state ğŸ”ï¸
    int slot_id;                             // Connection slot ğŸ”—
    const command_t *commands[MAX_PLAYER_COMMANDS]; // Command queue ğŸ“
    int command_timers[MAX_PLAYER_COMMANDS];  // Command timing â²ï¸
    int command_count;                        // Active commands ğŸ“Š
    char *current_command_line;               // Current command text ğŸ’¬
} player_t;
```

\subsection server_world_struct World Structure ğŸŒ

```c
typedef struct map_s {
    tile_t **tiles;          // 2D tile array ğŸ—ºï¸
    size_t width, height;    // World dimensions ğŸ“
} map_t;

typedef struct tile_s {
    int resources[RESOURCE_COUNT];    // Resources on tile ğŸ’
    player_t **players;              // Players on tile ğŸ‘¥
    size_t player_count;             // Player count ğŸ“Š
    size_t x, y;                     // Tile coordinates ğŸ“
    bool is_incantation_in_progress; // Elevation status ğŸª„
} tile_t;
```

\section server_initialization Server Initialization ğŸš€

\subsection server_init_flow Initialization Flow ğŸ”„

The server initialization follows this sequence:

1. **Signal Setup** ğŸ“¡
   ```c
   static void setup_signal_handling(void)
   {
       signal(SIGPIPE, SIG_IGN);  // Ignore broken pipe signals
   }
   ```

2. **Memory Allocation** ğŸ’¾
   ```c
   server_t *server = malloc(sizeof(server_t));
   memset(server, 0, sizeof(server_t));
   ```

3. **Network Initialization** ğŸŒ
   ```c
   if (init_network_integration() == -1) {
       // Handle network setup failure
   }
   ```

4. **Argument Processing** âš™ï¸
   ```c
   int handle_args(int argc, char **argv, server_t *server);
   ```

5. **World Creation** ğŸŒ
   ```c
   server->map = create_map(width, height);
   ```

\subsection server_arg_parsing Argument Parsing ğŸ“‹

Key parsing functions:
- `fill_port()`: Validates and sets network port ğŸ”Œ
- `fill_width()` / `fill_height()`: Sets world dimensions ğŸ“
- `handle_team_names()`: Processes team configuration ğŸ‘¥
- `validate_args()`: Ensures configuration validity âœ…

\section server_game_loop Game Loop Architecture ğŸ”„

\subsection server_main_loop Main Game Loop ğŸ®

```c
void game_loop_run(server_t *server)
{
    game_loop_init(server);           // Initialize game state ğŸš€
    if (!server->game_running)
        return;
    server_loop(server);              // Enter main loop ğŸ”
}
```

\subsection server_tick_processing Tick Processing â±ï¸

Each game tick processes:

1. **Network Events** ğŸ“¡
   ```c
   handle_client_connections(server);
   process_client_messages(server);
   ```

2. **Command Execution** âš¡
   ```c
   process_commands(server);  // Execute queued commands
   ```

3. **World Updates** ğŸŒ
   ```c
   handle_resource_spawn(server);    // Spawn resources
   handle_food_timers(server);       // Process food consumption
   check_player_deaths(server);      // Handle player deaths
   ```

4. **Game State Checks** ğŸ†
   ```c
   check_win_conditions(server);     // Check for victory
   ```

5. **GUI Updates** ğŸ–¥ï¸
   ```c
   send_gui_updates(server);         // Update graphic clients
   ```

\section server_command_system Command System âš¡

\subsection server_command_structure Command Architecture ğŸ—ï¸

Commands are implemented using a function pointer system:

```c
typedef struct command_s {
    char *name;                           // Command name ğŸ·ï¸
    int duration;                         // Execution time (ticks) â°
    void (*execute)(player_t *, server_t *); // Execution function ğŸ¯
} command_t;
```

\subsection server_command_processing Command Processing Flow ğŸ”„

1. **Command Reception** ğŸ“¨
   ```c
   bool commands_add(player_t *player, const char *command_name);
   ```

2. **Queue Management** ğŸ“
   - Commands are stored in player's command queue
   - Maximum `MAX_PLAYER_COMMANDS` (10) concurrent commands
   - Each command has an associated timer

3. **Execution** ğŸ¯
   ```c
   void process_commands(server_t *server)
   {
       // For each player
       // For each queued command
       // Decrement timer
       // Execute if timer reaches 0
   }
   ```

\subsection server_command_implementations Command Implementations ğŸ› ï¸

\subsubsection server_movement_impl Movement Commands ğŸš¶â€â™‚ï¸

```c
void cmd_forward(player_t *player, server_t *server)
{
    int new_x = player->x;
    int new_y = player->y;
    
    // Calculate new position based on orientation
    switch (player->orientation) {
        case NORTH: new_y--; break;
        case EAST:  new_x++; break;
        case SOUTH: new_y++; break;
        case WEST:  new_x--; break;
    }
    
    // Handle toroidal world wrapping
    normalize_coordinates_toroidal(&new_x, &new_y, 
                                   server->map->width, 
                                   server->map->height);
    
    move_player(player, new_x, new_y, server->map);
}
```

\subsubsection server_vision_impl Vision Implementation ğŸ‘ï¸

The `look` command implements a sophisticated vision system:

```c
char *get_player_vision(player_t *player, map_t *map)
{
    // Vision extends based on player level
    // Returns formatted string of visible tiles
    // Includes players, resources, and eggs
}
```

**Vision Pattern** ğŸ”:
- Level 1: 3 tiles (current + 2 ahead)
- Level 2: 8 tiles (pyramid pattern)
- Higher levels: Expanded pyramid

\subsubsection server_elevation_impl Elevation Implementation ğŸ”ï¸

```c
void cmd_incantation(player_t *player, server_t *server)
{
    // 1. Check elevation requirements
    if (!check_elevation_requirements(player, server)) {
        send_ko(player);
        return;
    }
    
    // 2. Gather required players
    player_t **participants = gather_elevation_participants(player, server);
    
    // 3. Consume resources
    consume_elevation_resources(player, server);
    
    // 4. Perform elevation
    elevate_players(participants, server);
    
    // 5. Notify GUI clients
    send_gui_incantation_info(server, player);
}
```

\section server_network_layer Network Layer ğŸŒ

\subsection server_libzappy_net libzappy_net Integration ğŸ”—

The server uses the custom `libzappy_net` library for networking:

```c
typedef struct server_connection_s {
    zn_socket_t zn_server;    // Server socket ğŸ”Œ
    client_t **clients;       // Connected clients ğŸ‘¥
    int client_count;         // Active connections ğŸ“Š
    int port;                 // Listen port ğŸšª
    server_args_t *args;      // Configuration ğŸ”§
} server_connection_t;
```

\subsection server_client_management Client Management ğŸ‘¥

\subsubsection server_client_types Client Types ğŸ·ï¸

```c
typedef enum {
    CLIENT_UNKNOWN = ZN_ROLE_UNKNOWN,
    CLIENT_IA = ZN_ROLE_AI,      // AI player client ğŸ¤–
    CLIENT_GUI = ZN_ROLE_GUI     // Graphical viewer ğŸ–¥ï¸
} client_type_t;
```

\subsubsection server_handshake_process Handshake Process ğŸ¤

1. **Connection Acceptance** ğŸ“
2. **Role Determination** ğŸ­
3. **Team Assignment** (for AI clients) ğŸ‘¥
4. **Player Creation** ğŸ‘¤
5. **World Synchronization** ğŸŒ

\subsection server_protocol_handling Protocol Handling ğŸ“‹

Key protocol functions:
- `handle_client_message()`: Process incoming messages ğŸ“¨
- `send_to_client()`: Send responses ğŸ“¤
- `broadcast_to_team()`: Team-wide messaging ğŸ“¢
- `send_gui_updates()`: GUI synchronization ğŸ–¥ï¸

\section server_resource_system Resource System ğŸ’

\subsection server_resource_types Resource Types ğŸ·ï¸

```c
enum resource_type {
    FOOD = 0,       // ğŸ–
    LINEMATE,       // ğŸ’
    DERAUMERE,      // ğŸ”·
    SIBUR,          // ğŸ”¸
    MENDIANE,       // ğŸ”¶
    PHIRAS,         // ğŸ”´
    THYSTAME        // ğŸŸ£
};
```

\subsection server_resource_management Resource Management ğŸ”„

\subsubsection server_resource_spawning Resource Spawning Algorithm ğŸŒ±

```c
void resource_spawn_periodic(map_t *map)
{
    // Calculate spawn probability based on current density
    for (int i = 0; i < RESOURCE_COUNT; i++) {
        float current_density = calculate_resource_density(map, i);
        float target_density = get_target_density(i);
        
        if (current_density < target_density) {
            spawn_resource_randomly(map, i);
        }
    }
}
```

\subsubsection server_resource_density Density Management ğŸ“Š

The server maintains optimal resource distribution:
- **Food**: Most abundant (survival critical) ğŸ–
- **Linemate**: Common (needed for all elevations) ğŸ’
- **Rare gems**: Limited availability (strategic value) ğŸ’

\section server_timing_system Timing System â°

\subsection server_timing_manager Timing Manager ğŸ›ï¸

```c
typedef struct timing_manager_s {
    int frequency;              // Server frequency (Hz) ğŸ“ˆ
    double tick_duration;       // Duration per tick (ms) â±ï¸
    struct timespec last_tick;  // Last tick timestamp ğŸ“…
    struct timespec next_tick;  // Next tick target ğŸ¯
} timing_manager_t;
```

\subsection server_command_timing Command Timing âš™ï¸

Each command has precise timing:
- **Movement**: 7 ticks ğŸš¶â€â™‚ï¸
- **Vision/Interaction**: 7 ticks ğŸ‘ï¸
- **Inventory**: 1 tick ğŸ’
- **Fork**: 42 ticks ğŸ¥š
- **Incantation**: 300 ticks ğŸª„

\section server_gui_protocol GUI Protocol ğŸ–¥ï¸

\subsection server_gui_commands GUI Command Set ğŸ“‹

The server implements a comprehensive GUI protocol:

```c
// Map information
void send_msz(client_t *client, server_t *server);  // Map size
void send_bct(client_t *client, server_t *server, int x, int y);  // Tile content
void send_mct(client_t *client, server_t *server);  // Full map

// Player information  
void send_ppo(client_t *client, player_t *player);  // Player position
void send_plv(client_t *client, player_t *player);  // Player level
void send_pin(client_t *client, player_t *player);  // Player inventory

// Game state
void send_sgt(client_t *client, server_t *server);  // Time frequency
void send_tna(client_t *client, server_t *server);  // Team names
```

\subsection server_real_time_updates Real-time Updates ğŸ“¡

The server maintains real-time synchronization:
- **Player movements** ğŸƒâ€â™‚ï¸
- **Resource changes** â™»ï¸
- **Incantation events** ğŸª„
- **Player deaths/births** ğŸ’€ğŸ£
- **Game state changes** ğŸ®

\section server_memory_management Memory Management ğŸ’¾

\subsection server_memory_allocation Memory Allocation Strategy ğŸ§®

The server implements careful memory management:

```c
// Server cleanup
void destroy_server(server_t *server)
{
    if (!server) return;
    
    // Clean up players
    for (size_t i = 0; i < server->player_count; i++) {
        destroy_player(server->players[i]);
    }
    free(server->players);
    
    // Clean up world
    destroy_map(server->map);
    
    // Clean up connections
    destroy_server_connection(server->connection);
    
    // Clean up GUI clients
    destroy_graphic_client_list(server->graphic_clients);
    
    // Free server structure
    free(server);
}
```

\subsection server_leak_prevention Leak Prevention ğŸš°

Key principles:
- **RAII pattern**: Every allocation has corresponding deallocation ğŸ”„
- **Null checks**: Defensive programming throughout ğŸ›¡ï¸
- **Error handling**: Clean up on failure paths ğŸ§¹
- **Valgrind testing**: Regular memory leak detection ğŸ”

\section server_error_handling Error Handling ğŸš¨

\subsection server_error_categories Error Categories ğŸ“Š

1. **Network Errors** ğŸŒ
   - Connection failures
   - Protocol violations
   - Client disconnections

2. **Game Logic Errors** ğŸ®
   - Invalid commands
   - Rule violations
   - State inconsistencies

3. **System Errors** ğŸ’»
   - Memory allocation failures
   - File system errors
   - Signal handling

\subsection server_error_recovery Error Recovery ğŸ”„

```c
typedef enum {
    ERROR_RECOVERABLE,    // Continue operation ğŸŸ¢
    ERROR_CLIENT_KICK,    // Disconnect client ğŸ”´
    ERROR_FATAL          // Shutdown server ğŸ’€
} error_severity_t;

void handle_error(server_t *server, error_severity_t severity, 
                  const char *message)
{
    log_error(message);
    
    switch (severity) {
        case ERROR_RECOVERABLE:
            // Log and continue
            break;
        case ERROR_CLIENT_KICK:
            // Disconnect problematic client
            break;
        case ERROR_FATAL:
            // Graceful server shutdown
            server->server_running = false;
            break;
    }
}
```

\section server_performance Performance Optimization ğŸš€

\subsection server_performance_tips Performance Considerations ğŸ“ˆ

1. **Efficient Data Structures** ğŸ—ï¸
   - Use arrays for frequent access
   - Linked lists for dynamic collections
   - Hash tables for lookups (where applicable)

2. **Memory Locality** ğŸ§ 
   - Keep related data together
   - Minimize pointer chasing
   - Use structure packing where beneficial

3. **Algorithm Complexity** ğŸ”
   - O(1) tile access via 2D array
   - O(n) player operations (where n = player count)
   - O(1) resource management per tile

\subsection server_scaling_considerations Scaling Considerations ğŸ“Š

For high-performance servers:
- **Multi-threading**: Consider parallel command processing ğŸ§µ
- **Load balancing**: Distribute world updates âš–ï¸
- **Memory pools**: Reduce allocation overhead ğŸŠâ€â™‚ï¸
- **Network optimization**: Batch GUI updates ğŸ“¦

\section server_debugging_tools Debugging Tools ğŸ”

\subsection server_logging Logging System ğŸ“

Implement comprehensive logging:
```c
#define LOG_DEBUG(fmt, ...) log_message(LOG_LEVEL_DEBUG, fmt, ##__VA_ARGS__)
#define LOG_INFO(fmt, ...)  log_message(LOG_LEVEL_INFO, fmt, ##__VA_ARGS__)
#define LOG_WARN(fmt, ...)  log_message(LOG_LEVEL_WARN, fmt, ##__VA_ARGS__)
#define LOG_ERROR(fmt, ...) log_message(LOG_LEVEL_ERROR, fmt, ##__VA_ARGS__)
```

\subsection server_debugging_techniques Debugging Techniques ğŸ› ï¸

1. **GDB Integration** ğŸ›
   ```bash
   gdb ./zappy_server
   (gdb) run -p 4242 -x 10 -y 10 -n Team1 Team2
   ```

2. **Valgrind Memory Checking** ğŸ”
   ```bash
   valgrind --leak-check=full ./zappy_server <args>
   ```

3. **Network Debugging** ğŸ“¡
   ```bash
   netstat -tulpn | grep :4242
   tcpdump -i lo port 4242
   ```

\section server_extending Extending the Server ğŸ”§

\subsection server_new_commands Adding New Commands â•

1. **Define Command Structure** ğŸ“
   ```c
   void cmd_new_action(player_t *player, server_t *server);
   ```

2. **Register Command** ğŸ“‹
   ```c
   static const command_t commands[] = {
       // ... existing commands ...
       {"new_action", 10, cmd_new_action},
   };
   ```

3. **Implement Logic** ğŸ¯
   ```c
   void cmd_new_action(player_t *player, server_t *server)
   {
       // Your custom logic here
       // Remember to send appropriate responses
   }
   ```

\subsection server_new_features Adding New Features ğŸŒŸ

When adding features:
1. **Plan the API** ğŸ“: Define interfaces first
2. **Update Protocol** ğŸ“‹: Extend GUI communication if needed
3. **Test Thoroughly** ğŸ§ª: Unit tests + integration tests
4. **Document Changes** ğŸ“š: Update both user and dev guides

\section server_testing Testing Strategy ğŸ§ª

\subsection server_test_categories Test Categories ğŸ“Š

1. **Unit Tests** ğŸ”¬
   - Individual function testing
   - Mock dependencies
   - Edge case validation

2. **Integration Tests** ğŸ”—
   - Component interaction testing
   - Protocol compliance
   - End-to-end scenarios

3. **Load Tests** ğŸ“ˆ
   - Multiple client connections
   - High-frequency operations
   - Memory usage under load

\subsection server_test_automation Test Automation ğŸ¤–

```bash
# Run automated tests
make test

# Run with coverage
make test-coverage

# Performance benchmarks
make benchmark
```

\section server_best_practices Best Practices ğŸ†

\subsection server_code_style Code Style Guidelines ğŸ“

1. **Naming Conventions** ğŸ·ï¸
   - Functions: `snake_case`
   - Structures: `snake_case_t`
   - Constants: `UPPER_CASE`
   - Enums: `ENUM_VALUE`

2. **Error Handling** ğŸš¨
   - Always check return values
   - Use meaningful error messages
   - Clean up resources on error

3. **Documentation** ğŸ“š
   - Document all public functions
   - Explain complex algorithms
   - Keep docs updated with code

\subsection server_security_considerations Security Considerations ğŸ”’

1. **Input Validation** âœ…
   - Sanitize all client input
   - Validate command arguments
   - Check bounds on all operations

2. **Resource Limits** âš–ï¸
   - Limit client connections
   - Prevent command flooding
   - Monitor resource usage

3. **Network Security** ğŸ›¡ï¸
   - Handle malformed packets gracefully
   - Implement connection timeouts
   - Log suspicious activity

\section server_conclusion Happy Coding! ğŸ‰

You now have a comprehensive understanding of the Zappynian server architecture! The modular design makes it easy to extend and maintain. Remember:

- **Keep it simple** ğŸ¯: Prefer clear code over clever tricks
- **Test everything** ğŸ§ª: Good tests prevent bugs
- **Document changes** ğŸ“: Help future developers (including yourself!)
- **Performance matters** ğŸš€: But readability comes first

The server is the foundation of the entire Zappynian experience. Build it well, and players will have endless fun competing in your digital world! ğŸŒâœ¨

---
*May your code compile clean and your servers run fast!* ğŸ’»âš¡
*/
